<!DOCTYPE html>
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>SPH - WebGL&WebCL Interop</title>
<meta HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">

<style type="text/css">

#my-gui-container {
    /*margin-top: 600px;*/
}

h2 {
    color:#FFFFFF;
    margin-left: 20px;
    text-align: left;
}

p {
    color: #00FF00;
    margin-left: 20px;
}

#stats {
    position: absolute;
    top: 420px;
    width: 240px;

    /*border-style: inset;*/
    border-style: groove;
}

#submit {
    position: absolute;
    top: 520px;
    left: 10px;
    width: 240px;

    /*border-style: inset;*/
    border-style: groove;
}

#output {
    position: absolute;
    top: 0px;
    width: 0px;
    height: 0px;
    left: 720px;
    background-color: #FFF;
    display: none;
    /*border-style: groove;   */
} 

</style>

<script id="particle-vshader" type="x-shader/x-vertex">
    precision mediump float;
    uniform mat4 mvp;
    attribute vec4 position;
    attribute vec4 velocity;
    attribute vec4 acceleration;
    attribute vec2 particleIndex;
    attribute vec4 prevPosition;
    attribute vec4 sortedVelocity;
    attribute float gridCellIndex;
    attribute float gridCellIndexFixedUp;
    
    varying vec4 vColor;

    varying vec3 vVel;
    varying vec3 vPos;

    void main(void) {
        vec4 pos;
        
        pos.xyz = position.xyz;
        pos.w  = 1.0;

        vVel = velocity.xyz;

        vPos = position.xyz;

        gl_Position = mvp * pos;

        vColor = vec4(0.8, 0.8, .8, 1.0);

        gl_PointSize  = 10.0;
    }
</script>

<script id="particle-fshader" type="x-shader/x-fragment">
    
    precision mediump float;
    
    varying vec4 vColor;
    
    varying vec3 vVel;
    varying vec3 vPos;

    void main(void) {
        vec4 InnerColor = vec4(.6, .2, .10, 1.0);
        // vec4 InnerColor = vec4(0.0, 0.392157, 0.0, 1.0);
        // vec4 InnerColor = vec4(0.294118, 0.0, 0.509804, 1.0);
        vec4 OuterColor = vec4(0.0, 0.0, 0.0, 1.0);

        float dx = (gl_PointCoord.x - 0.5);
        float dy = (gl_PointCoord.y - 0.5);
        
        float r = sqrt(dx*dx + dy*dy);
        float r1 = 0.1;

        gl_FragColor = vec4(mix(InnerColor, OuterColor, smoothstep(r1, 1.0, r)));
    }

</script>

<script id="triangle-vshader" type="x-shader/x-vertex">
    precision mediump float;
    uniform mat4 mvp;
    attribute vec3 marchingcube;
    
    varying vec4 vColor;

    void main(void) {
        vec4 pos;
        
        pos = vec4(marchingcube.xyz, 1.0);

        gl_Position = mvp * pos;

        vColor = vec4(1.0, 0.0, 0.0, 1.0);

        gl_PointSize  = 2.0;
    }

</script>

<script id="triangle-fshader" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;
    
    void main(void) {
        
        gl_FragColor = vColor;
    }

</script>

<script id="cube-vshader" type="x-shader/x-vertex">
    precision mediump float;
    uniform mat4 mvp;
    uniform mat4 np;

    attribute vec3 cube;
    attribute vec3 vNormal;

    varying vec4 position;
    varying vec3 light;
    varying vec3 normal;

    varying vec3 eye;
    
    void main()
    {
        vec3 lightPos = vec3(0.0, 0.0, 3.0);
        vec3 eyePos = vec3(0.0, 0.0, 0.0);

        position = vec4(cube.xyz, 1.0);

        vec4 N = normalize(np * vec4(vNormal, 1.0));

        normal = N.xyz;

        light = lightPos - position.xyz;
        eye = eyePos - position.xyz;

        position = mvp * position;
        
        gl_Position = position;
    }

</script>

<script id="cube-fshader" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 position;
    varying vec3 light;
    varying vec3 normal;

    varying vec3 eye;

    void main() {
        
        vec3 nNormal = normalize(normal);
        vec3 nVertToLight = normalize(light);
        vec3 nVertToEye = normalize(eye);

        float ambientTerm = 0.02;
        vec3 ambientColor = vec3(.4, .4, .4);
        vec3 Iamb = ambientColor * ambientTerm;

        float dotVL = clamp(dot(nNormal, nVertToLight), 0.0, 1.0);
        float diffuseTerm = .3;
        // vec3 diffuseColor = vec3(0.74, 0.71, 0.42);
        vec3 diffuseColor = vec3(0.6, 0.6, 0.6);
        vec3 Idiff = diffuseColor * diffuseTerm * dotVL;
        
        float shinness = 100.;
        float specularTerm = 1.0 - ambientTerm - diffuseTerm;
        vec3 specularColor = vec3(1.0, 1.0, 1.0);
        
        vec3 H = normalize(nVertToEye + nVertToLight);
        float dotNH = clamp(dot(nNormal, H), 0.0, 1.0);

        vec3 Ispec = specularColor * specularTerm * pow(dotNH, shinness);

        vec3 color = Iamb + Idiff + Ispec;

        gl_FragColor = vec4(color, 1.0);
        
    }
</script>

<script id="plane-vshader" type="x-shader/x-vertex">

    precision mediump float;
    uniform mat4 mvp;
    uniform mat4 np;

    attribute vec3 plane;
    attribute vec3 vNormal;

    varying vec4 position;
    varying vec3 light;
    varying vec3 normal;
    
    void main()
    {
        position = vec4(plane.xyz, 1.0);
        position = mvp * position;
        
        gl_Position = position;
    }   

</script>

<script id="plane-fshader" type="x-shader/x-fragment">

    precision mediump float;

    varying vec4 position;
    varying vec3 light;
    varying vec3 normal;

    void main() {
        gl_FragColor = vec4(0.5, 0.08, 0.1, 1.0);

    }

</script>

<script id="sph_kernel_applyBodyForce" type="x-kernel">

    __kernel void sph_kernel_applyBodyForce(
            int kParticleCount,
            __global float4* vel,
            float dt)
    {
        unsigned int gid = get_global_id(0);

        vel[gid].y -= 9.8 * dt;
    }

</script>

<script id="sph_kernel_advance" type="x-kernel">

    __kernel void sph_kernel_advance(
        int kParticleCount,
        float dt,
        __global float4* position,
        __global float4* prevPos,
        __global float4* velocity)
    {
        unsigned int gid = get_global_id(0);
        
        prevPos[gid].xyzw = position[gid].xyzw;
        position[gid].xyz += (float3)(dt) * velocity[gid].xyz;
    }

</script>

<script id="sph_kernel_hashparticles" type="x-kernel">
    
    __kernel void sph_kernel_hashparticles(
        float viewWidth,
        float viewHeight,
        float viewDepth,
        int nx,
        int ny,
        int nz,
        float cellSize,
        __global float4* pos,
        __global uint2* partIdx,
        __global float4* vel)
    {
        unsigned int gid = get_global_id(0);

        float3 tempPos;
        // pos(x, y, z) in [-viewWidth/2, viewWidth/2] mapped to [0, nx*cellSize]
        // newPos = (val - src0) / (src1 - src0) * (dst1 - dst0) + dst0
        float rangeRatioX = (nx * cellSize - 0.0f) / viewWidth;
        float rangeRatioY = (ny * cellSize - 0.0f) / viewHeight;
        float rangeRatioZ = (nz * cellSize - 0.0f) / viewDepth;
        
        tempPos.x = (pos[gid].x - (-viewWidth/2) ) * rangeRatioX;
        tempPos.y = (pos[gid].y - (-viewHeight/2)) * rangeRatioY;
        tempPos.z = (pos[gid].z - (-viewDepth/2) ) * rangeRatioZ;

        // myPos(x, y, z) in [0, nx*cellSize] mapped to 3d voxel coords [v3d.x, v3d.y, v3d.z]
        // each between the range [0, n] (assuming cubic space)
        float3 voxel3d;
        voxel3d.x = tempPos.x / cellSize;
        voxel3d.y = tempPos.y / cellSize;
        voxel3d.z = tempPos.z / cellSize;

        int voxelID = floor(voxel3d.x) + floor(voxel3d.y) * nx + floor(voxel3d.z) * nx * ny;
        
        pos[gid].w = voxelID;
        
        partIdx[gid].x = voxelID;
        partIdx[gid].y = gid;        

    }

</script>

<!-- 
    Bitonic sort code source: 
    https://github.com/clockfort/amd-app-sdk-fixes/blob/master/samples/opencl/cl/app/BitonicSort/BitonicSort_Kernels.cl 
-->
<script id="sph_kernel_sort" type="x-kernel">

    __kernel void sph_kernel_sort (
        __global uint2* partIdx,
        int stage,
        int passOfStage,
        int direction) 
    {
        uint sortIncreasing = direction;
        uint threadId = get_global_id(0);
    
        uint pairDistance = 1 << (stage - passOfStage);
        uint blockWidth   = 2 * pairDistance;

        uint leftId = (threadId % pairDistance) 
                   + (threadId / pairDistance) * blockWidth;

        uint rightId = leftId + pairDistance;
    
        uint2 leftElement = partIdx[leftId];
        uint2 rightElement = partIdx[rightId];
    
        uint sameDirectionBlockWidth = 1 << stage;
    
        if((threadId/sameDirectionBlockWidth) % 2 == 1)
            sortIncreasing = 1 - sortIncreasing;

        uint2 greater;
        uint2 lesser;
        if(leftElement.x > rightElement.x)
        {
            greater = leftElement;
            lesser  = rightElement;
        }
        else
        {
            greater = rightElement;
            lesser  = leftElement;
        }
    
        if(sortIncreasing)
        {
            partIdx[leftId]  = lesser;
            partIdx[rightId] = greater;
        }
        else
        {
            partIdx[leftId]  = greater;
            partIdx[rightId] = lesser;
        }
    }

</script>

<script id="sph_kernel_sortPostPass" type="x-kernel">
    
    __kernel void sph_kernel_sortPostPass (
        __global float4* pos,
        __global float4* vel,
        __global uint2* partIdx,
        __global float4* sortedPos,
        __global float4* sortedVel,
        __global float4* prevPos,
        __global float4* sortedPrevPos)
    {
        unsigned int gid = get_global_id(0);

        int particleID = partIdx[gid].y;

        // float4 tempPos = pos[particleID];

        sortedPos[gid].x = pos[particleID].x;
        sortedPos[gid].y = pos[particleID].y;
        sortedPos[gid].z = pos[particleID].z;
        sortedPos[gid].w = pos[particleID].w;

        // float4 tempVel = vel[particleID];

        sortedVel[gid].x = vel[particleID].x;
        sortedVel[gid].y = vel[particleID].y;
        sortedVel[gid].z = vel[particleID].z;
        sortedVel[gid].w = vel[particleID].w;

        // float4 tempPrevPos = prevPos[particleID];

        sortedPrevPos[gid].x = prevPos[particleID].x;
        sortedPrevPos[gid].y = prevPos[particleID].y;
        sortedPrevPos[gid].z = prevPos[particleID].z;
        sortedPrevPos[gid].w = prevPos[particleID].w;

        barrier(CLK_GLOBAL_MEM_FENCE);

        // pos[gid].x = sortedPos[gid].x;
        // pos[gid].y = sortedPos[gid].y;
        // pos[gid].z = sortedPos[gid].z;
        // pos[gid].w = sortedPos[gid].w;

        // vel[gid].x = sortedVel[gid].x;
        // vel[gid].y = sortedVel[gid].y;
        // vel[gid].z = sortedVel[gid].z;
        // vel[gid].w = sortedVel[gid].w;
        
        pos[particleID].x = sortedPos[particleID].x;
        pos[particleID].y = sortedPos[particleID].y;
        pos[particleID].z = sortedPos[particleID].z;
        pos[particleID].w = sortedPos[particleID].w;

        barrier(CLK_GLOBAL_MEM_FENCE);

        vel[particleID].x = sortedVel[particleID].x;
        vel[particleID].y = sortedVel[particleID].y;
        vel[particleID].z = sortedVel[particleID].z;
        vel[particleID].w = sortedVel[particleID].w;
    }

</script>

<script id="sph_kernel_indexx" type="x-kernel">

    __kernel void sph_kernel_indexx(
        int kParticleCount,
        // __global float4* sortedPos,
        __global float4* pos,
        __global int* gridCellIdx)
    {
        unsigned int gid = get_global_id(0);
        gridCellIdx[gid] = -1;

        // binary search into sortedPos and find first particle
        // in voxel gid

        int low = 0;
        int hi = kParticleCount - 1;
        int mid = 0;

        while (low <= hi) {
            mid = (hi + low) / 2;
            // if (floor(sortedPos[mid].w) == gid) {
            if (floor(pos[mid].w) == gid) {    
                int front = mid - 1;
                
                // while((front >= 0) && (floor(sortedPos[front].w) == gid))
                while((front >= 0) && (floor(pos[front].w) == gid))
                {
                    front--;
                }

                if (mid > front - 1)
                {
                    gridCellIdx[gid] = front + 1;
                }

                break;

            // } else if ( sortedPos[mid].w < gid) {
            } else if ( pos[mid].w < gid) {                
                low = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
    }

</script>

<script id="sph_kernel_indexPostPass" type="x-kernel">
    
    __kernel void sph_kernel_indexPostPass(
        int kParticleCount,
        __global int* gridCellIdx,
        __global int* gridCellIdxFixedUp)
    {
        unsigned int gid = get_global_id(0);
        
        if (gridCellIdx[gid] != -1)
        {
            gridCellIdxFixedUp[gid] = gridCellIdx[gid];
        } else {
            int preCell = gid;
        
            while (preCell >= 0) 
            {
                int pid = gridCellIdx[preCell];
                if (pid != -1)
                {
                    gridCellIdxFixedUp[gid] = pid;
                    break;
                }
                else {
                    preCell--;
                }
            }
        }
    }

</script>

<script id="sph_kernel_findNeighbors" type="x-kernel">

    __kernel void sph_kernel_findNeighbors(
        int kParticleCount,
        float viewW,
        float viewH,
        float viewD,
        int nx,
        int ny,
        int nz,
        float cellSize,
        __global float4* pos,
        __global int* gridCellIdxFixedUp,
        __global int* neighborMap,
        int maxNeighbors,
        float kEpsilon)
    {
        unsigned int gid = get_global_id(0);
        
        float3 myPos = pos[gid].xyz;

        int count = 0;
        int i;
        int j;

        // set all entries to be the particle itself
        for (i = 0; i < maxNeighbors; i++)
        {
            neighborMap[maxNeighbors*gid+i] = gid;
        }

        for (j = 0; j < kParticleCount; j++)
        {
            // float3 particleJ = sortedPos[j].xyz;
            float3 particleJ = pos[j].xyz;
            float dist = length(myPos.xyz - particleJ);

            if ((dist >= kEpsilon) && (dist <= cellSize) && (j != gid))
            {
                neighborMap[maxNeighbors*gid+count] = j;
                count++;
                if (count == maxNeighbors)
                    break;
            }
        }
    }

</script>

<script id="sph_kernel_pressure" type="x-kernel">

    __kernel void sph_kernel_pressure(
        float m,
        float cellSize,
        float kNorm,
        float kNearNorm,
        int maxNeighbors,
        float kStiffness,
        float kNearStiffness,
        float kRestDensity,
        float kEpsilon,
        __global float4* pos,
        __global int* neighborMap,
        __global float* density,
        __global float* nearDensity,
        __global float* pressure,
        __global float* nearPressure)
    {
        unsigned int gid = get_global_id(0);    

        float3 myPos = pos[gid].xyz;

        int i;
        float3 posJ;
        float tempDens = 0.0;
        float tempNearDens = 0.0;

        for (i = 0; i < maxNeighbors; i++)
        {
            int nID = neighborMap[maxNeighbors * gid+i];
            if (nID == gid)
                continue;

            posJ = pos[nID].xyz;

            float r = length(myPos - posJ);

            float a = 1 - r/cellSize;

            tempDens += m * a * a * a * kNorm;
            tempNearDens += m * a * a * a * a * kNearNorm;
            
        }

        density[gid] = tempDens;
        nearDensity[gid] = tempNearDens;
        pressure[gid] = kStiffness * (tempDens - m * kRestDensity);
        nearPressure[gid] = kNearStiffness * tempNearDens;

    }

</script>

<script id="mc_kernel_gridval" type="x-kernel">

    __kernel void mc_kernel_gridval(
        int kParticleCount,
        float m,
        float cellSize,
        float kNorm,
        float kEpsilon,
        __global float4* pos,
        __global float* mcgrid)
    {
        unsigned int gid = get_global_id(0);

        // marching cubes step: update grid point values
        // each particle update up to 8 vertices
        float3 vertPos0 = float3(mcgrid[32*gid+0], mcgrid[32*gid+1], mcgrid[32*gid+2]);
        float3 vertPos1 = float3(mcgrid[32*gid+4], mcgrid[32*gid+5], mcgrid[32*gid+6]);
        float3 vertPos2 = float3(mcgrid[32*gid+8], mcgrid[32*gid+9], mcgrid[32*gid+10]);
        float3 vertPos3 = float3(mcgrid[32*gid+12], mcgrid[32*gid+13], mcgrid[32*gid+14]);
        float3 vertPos4 = float3(mcgrid[32*gid+16], mcgrid[32*gid+17], mcgrid[32*gid+18]);
        float3 vertPos5 = float3(mcgrid[32*gid+20], mcgrid[32*gid+21], mcgrid[32*gid+22]);
        float3 vertPos6 = float3(mcgrid[32*gid+24], mcgrid[32*gid+25], mcgrid[32*gid+26]);
        float3 vertPos7 = float3(mcgrid[32*gid+28], mcgrid[32*gid+29], mcgrid[32*gid+30]);

        float r = 0.0;
        float a = 0.0;
        
        float tempDens0 = 0.0;
        float tempDens1 = 0.0;
        float tempDens2 = 0.0;
        float tempDens3 = 0.0;
        float tempDens4 = 0.0;
        float tempDens5 = 0.0;
        float tempDens6 = 0.0;
        float tempDens7 = 0.0;
        
        float3 pPos = float3(0.0, 0.0, 0.0);

        int i;
        for (i = 0; i < kParticleCount; i++)
        {   
            pPos = pos[i].xyz;

            r = length(pPos - vertPos0);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens0 += m * a * a * kNorm;
            }

            r = length(pPos - vertPos1);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens1 += m * a * a * kNorm;
            }
            
            r = length(pPos - vertPos2);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens2 += m * a * a * kNorm;
            }
            
            r = length(pPos - vertPos3);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens3 += m * a * a * kNorm;
            }
            
            r = length(pPos - vertPos4);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens4 += m * a * a * kNorm;
            }
            
            r = length(pPos - vertPos5);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens5 += m * a * a * kNorm;
            }
            
            r = length(pPos - vertPos6);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens6 += m * a * a * kNorm;
            }
            
            r = length(pPos - vertPos7);
            if ((r >= kEpsilon) && (r <= cellSize))
            {
                a = 1.0 - r/cellSize;
                tempDens7 += m * a * a * kNorm;
            }

        }

        mcgrid[32*gid+3] = tempDens0;
        mcgrid[32*gid+7] = tempDens1;
        mcgrid[32*gid+11] = tempDens2;
        mcgrid[32*gid+15] = tempDens3;
        mcgrid[32*gid+19] = tempDens4;
        mcgrid[32*gid+23] = tempDens5;
        mcgrid[32*gid+27] = tempDens6;
        mcgrid[32*gid+31] = tempDens7;
        
    }
</script>

<script id="mc_kernel_cubeindex" type="x-kernel">
    
    __kernel void mc_kernel_cubeindex(
        float isolevel,
        __global float* mcgrid,
        __global unsigned char* cubeindex)
    {
        unsigned int gid = get_global_id(0);

        unsigned char idx;
        
        // if (mcgrid[32*gid+3] < isolevel)  idx |= 1;
        // if (mcgrid[32*gid+7] < isolevel)  idx |= 2;
        // if (mcgrid[32*gid+11] < isolevel) idx |= 4;
        // if (mcgrid[32*gid+15] < isolevel) idx |= 8;
        // if (mcgrid[32*gid+19] < isolevel) idx |= 16;
        // if (mcgrid[32*gid+23] < isolevel) idx |= 32;
        // if (mcgrid[32*gid+27] < isolevel) idx |= 64;
        // if (mcgrid[32*gid+31] < isolevel) idx |= 128;

        idx =  (mcgrid[32*gid+3] < isolevel);
        idx += (mcgrid[32*gid+7] < isolevel)*2;
        idx += (mcgrid[32*gid+11] < isolevel)*4;
        idx += (mcgrid[32*gid+15] < isolevel)*8;
        idx += (mcgrid[32*gid+19] < isolevel)*16;
        idx += (mcgrid[32*gid+23] < isolevel)*32;
        idx += (mcgrid[32*gid+27] < isolevel)*64;
        idx += (mcgrid[32*gid+31] < isolevel)*128;

        cubeindex[gid] = idx;
    }

</script>

<script id="mc_kernel_polygonisecube" type="x-kernel">

    float ABS(float diff)
    {
        if (diff < 0)
            return -1.0*diff;
        else
            return diff;
    }

    float3 VertexInterp(float isoval, float4 p1, float4 p2)
    {
        float mu;
        float3 p = float3(0.0, 0.0, 0.0);

        if (ABS(isoval - p1.w) < 0.00001)
        {
            p = p1.xyz;
            
        }

        if (ABS(isoval - p2.w) < 0.00001)
        {
            p = p2.xyz;
            
        } 

        if (ABS(p1.w - p2.w) < 0.00001)
        {
            p = p1.xyz;
            
        } 

        mu = (isoval - p1.w) / (p2.w - p1.w);
        p.x = p1.x + mu * (p2.x - p1.x);
        p.y = p1.y + mu * (p2.y - p1.y);
        p.z = p1.z + mu * (p2.z - p1.z);

        p.x = mu;
        p.y = mu;
        p.z = mu;
        
        return p;
    }
    
    __kernel void mc_kernel_polygonisecube(
        __global unsigned short* edgetable,
        __global signed char* tritable,
        __global unsigned char* cubeindex,
        __global float* mcgrid,
        float isolevel,
        __global float* triangles,
        __global char* trianglescount)
    {
        unsigned int gid = get_global_id(0);
        
        unsigned char cubeidx = cubeindex[gid];
        unsigned short edges = edgetable[cubeidx];

        float4 vert0 = float4(mcgrid[32*gid+0],  mcgrid[32*gid+1],  mcgrid[32*gid+2],  mcgrid[32*gid+3]);
        float4 vert1 = float4(mcgrid[32*gid+4],  mcgrid[32*gid+5],  mcgrid[32*gid+6],  mcgrid[32*gid+7]);
        float4 vert2 = float4(mcgrid[32*gid+8],  mcgrid[32*gid+9],  mcgrid[32*gid+10], mcgrid[32*gid+11]);
        float4 vert3 = float4(mcgrid[32*gid+12], mcgrid[32*gid+13], mcgrid[32*gid+14], mcgrid[32*gid+15]);
        float4 vert4 = float4(mcgrid[32*gid+16], mcgrid[32*gid+17], mcgrid[32*gid+18], mcgrid[32*gid+19]);
        float4 vert5 = float4(mcgrid[32*gid+20], mcgrid[32*gid+21], mcgrid[32*gid+22], mcgrid[32*gid+23]);
        float4 vert6 = float4(mcgrid[32*gid+24], mcgrid[32*gid+25], mcgrid[32*gid+26], mcgrid[32*gid+27]);
        float4 vert7 = float4(mcgrid[32*gid+28], mcgrid[32*gid+29], mcgrid[32*gid+30], mcgrid[32*gid+31]);

        char ntriangle = 0;

        float3 vertlist[12];

        // cube is entirely in/out of the surface
        if (edges == 0)
        {
            ntriangle = 0;
        }
        else
        {
            if (edges & 1)
            {
                vertlist[0] = VertexInterp(isolevel, vert0, vert1);
            } else if (edges & 2)
            {
                vertlist[1] = VertexInterp(isolevel, vert1, vert2);
            } else if (edges & 4)
            {
                vertlist[2] = VertexInterp(isolevel, vert2, vert3);
            } else if (edges & 8)
            {
                vertlist[3] = VertexInterp(isolevel, vert3, vert0);
            } else if (edges & 16)
            {
                vertlist[4] = VertexInterp(isolevel, vert4, vert5);
            } else if (edges & 32)
            {
                vertlist[5] = VertexInterp(isolevel, vert5, vert6);
            } else if (edges & 64)
            {
                vertlist[6] = VertexInterp(isolevel, vert6, vert7);
            } else if (edges & 128)
            {
                vertlist[7] = VertexInterp(isolevel, vert7, vert4);
            } else if (edges & 256)
            {
                vertlist[8] = VertexInterp(isolevel, vert0, vert4);
            } else if (edges & 512)
            {
                vertlist[9] = VertexInterp(isolevel, vert1, vert5);
            } else if (edges & 1024)
            {
                vertlist[10] = VertexInterp(isolevel, vert2, vert6);
            } else if (edges & 2048)
            {
                vertlist[11] = VertexInterp(isolevel, vert3, vert7);
            }
            
            int i;
            
            for (i=0; tritable[cubeidx*16+i] != -1; i+=3)
            {
                triangles[45*gid+9*i+0] = vertlist[tritable[cubeidx * 16 + i]].x;
                triangles[45*gid+9*i+1] = vertlist[tritable[cubeidx * 16 + i]].y;
                triangles[45*gid+9*i+2] = vertlist[tritable[cubeidx * 16 + i]].z;
                
                triangles[45*gid+9*i+3] = vertlist[tritable[cubeidx * 16 + i + 1]].x;
                triangles[45*gid+9*i+4] = vertlist[tritable[cubeidx * 16 + i + 1]].y;
                triangles[45*gid+9*i+5] = vertlist[tritable[cubeidx * 16 + i + 1]].z;

                triangles[45*gid+9*i+6] = vertlist[tritable[cubeidx * 16 + i + 2]].x;
                triangles[45*gid+9*i+7] = vertlist[tritable[cubeidx * 16 + i + 2]].y;
                triangles[45*gid+9*i+8] = vertlist[tritable[cubeidx * 16 + i + 2]].z;

                ntriangle++;
            }
        }
        
        trianglescount[gid] = ntriangle;        
    }

</script>

<script id="mc_kernel_packtriangles" type="x-kernel">

    __kernel void mc_kernel_packtriangles(
        __global float* triangles,
        __global char* trianglescount,
        __global float* trianglesRender)
    {
        unsigned int gid = get_global_id(0);

        // char beforeMe = 0;

        // int i;
        // for (i = 0; i < gid; i++)
        // {
        //     beforeMe += trianglescount[i];
        // }

        // for (i = 0; i < trianglescount[gid]; i++)
        // {
        //     // trianglesRender[3*beforeMe+3*i+0] = triangles[15*gid+3*i+0];
        //     // trianglesRender[3*beforeMe+3*i+1] = triangles[15*gid+3*i+1];
        //     // trianglesRender[3*beforeMe+3*i+2] = triangles[15*gid+3*i+2];
        //     trianglesRender[15*gid+3*i+0] = triangles[15*gid+3*i+0];
        //     trianglesRender[15*gid+3*i+1] = triangles[15*gid+3*i+1];
        //     trianglesRender[15*gid+3*i+2] = triangles[15*gid+3*i+2];
        // }
        
        trianglesRender[45*gid+0] = triangles[45*gid+0];
        trianglesRender[45*gid+1] = triangles[45*gid+1];
        trianglesRender[45*gid+2] = triangles[45*gid+2];

    }

</script>

<script id="sph_kernel_calcRelaxPos" type="x-kernel">

    __kernel void sph_kernel_calcRelaxPos(
        float m,
        float cellSize,
        float dt,
        float dt2,
        float kNearNorm,
        float kNorm,
        float kSurfaceTension,
        float kLinearViscocity,
        float kQuadraticViscocity,
        int maxNeighbors,
        __global float4* pos,
        __global float4* vel,
        __global int* neighborMap,
        __global float* density,
        __global float* nearDensity,
        __global float* pressure,
        __global float* nearPressure,
        __global float4* relaxPos)
    {
        unsigned int gid = get_global_id(0);

        float3 myPos = pos[gid].xyz;
        float3 myVel = vel[gid].xyz;

        float x = myPos.x;
        float y = myPos.y;
        float z = myPos.z;

        int i;
        float3 posJ;
        float3 velJ;

        for (i = 0; i < maxNeighbors; i++)
        {
            int nID = neighborMap[maxNeighbors * gid+i];
            if (nID == gid)
                continue;

            posJ = pos[nID].xyz;

            float3 diff = posJ - myPos;
            float r = length(diff);

            float dx = diff.x;
            float dy = diff.y;
            float dz = diff.z;

            float a = 1 - r/cellSize;

            float d = dt2 * ((nearPressure[gid] + nearPressure[nID]) * a * a * a * kNearNorm + (pressure[gid] + pressure[nID]) * a * a * kNorm) / 2.0;

            x -= d * dx / (r * m);
            y -= d * dy / (r * m);
            z -= d * dz / (r * m);

            x += (kSurfaceTension/m) * m * a * a * kNorm * dx;
            y += (kSurfaceTension/m) * m * a * a * kNorm * dy;
            z += (kSurfaceTension/m) * m * a * a * kNorm * dz;

            velJ = vel[nID].xyz;

            float3 diffV = myVel - velJ;
            float u = diffV.x * dx + diffV.y * dy + diffV.z * dz;

            if (u > 0)
            {
                u /= r;

                float a = 1 - r/cellSize;

                float I = .5 * dt * a * (kLinearViscocity * u + kQuadraticViscocity * u * u);

                x -= I * dx * dt;
                y -= I * dy * dt;
                z -= I * dz * dt;
            }
        }

        relaxPos[gid].x = x;
        relaxPos[gid].y = y;
        relaxPos[gid].z = z;

    }

</script>

<script id="sph_kernel_moveToRelaxPos" type="x-kernel">

    __kernel void sph_kernel_moveToRelaxPos(
        float dt,
        __global float4* pos,
        __global float4* prevPos,
        __global float4* vel,
        __global float4* relaxPos)
    {
        unsigned int gid = get_global_id(0);

        pos[gid].x = relaxPos[gid].x;
        pos[gid].y = relaxPos[gid].y;
        pos[gid].z = relaxPos[gid].z;

        vel[gid].x = (pos[gid].x - prevPos[gid].x) / dt;
        vel[gid].y = (pos[gid].y - prevPos[gid].y) / dt;
        vel[gid].z = (pos[gid].z - prevPos[gid].z) / dt;

    }

</script>

<script id="sph_kernel_resolveCollisions" type="x-kernel">

    __kernel void sph_kernel_resolveCollisions(
        float dt,
        float pRadius,
        float viewW,
        float viewH,
        float viewD,
        __global float4* pos,
        __global float4* vel)
    {
        unsigned int gid = get_global_id(0);

        float3 myPos = pos[gid].xyz;
        float3 myVel = vel[gid].xyz;

        float3 center         = float3(0.0);
        float3 boxSize        = float3(viewW/2-pRadius, viewH/2-pRadius, viewD/2-pRadius);
        
        float3 xLocal = myPos - center;
        float3 contactPointLocal = min(boxSize, max(-boxSize, xLocal));
        float3 contactPoint = contactPointLocal + center;
        float distance = length(contactPoint - myPos);
        
        if (distance > 0.0 && length(myVel) > 0.0) 
        {
            float3 normal = normalize(sign(contactPointLocal - xLocal));
            float restitution = .5*distance / (dt * length(myVel));
            
            vel[gid].xyz -= (float3)((1.0 + restitution) * dot(myVel, normal)) * normal;
            pos[gid].xyz = contactPoint;
        }

    }

</script>

<script type="text/javascript" src="/socket.io/socket.io.js"></script> 
<!--The above library(/socket.io/socket.io.js) will be generated by socket.io module of server -->
<script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>

<script type="text/javascript" src="Util/dat.gui.js"></script>
<script src="Util/sampler.js"></script>
<script src="Util/shader.js"></script>
<script src="Util/J3DIMath.js"></script>

<script src="Controller.js"></script>
<script src="InitSim.js"></script>
<script src="MarchingCubes.js"></script>
<script src="SimCL.js"></script>
<script src="SimJS.js"></script>
<script src="DrawGL.js"></script>
<script src="DrawJS.js"></script>

</head>

<body onload="onLoad()" bgColor="#202020">
    <!-- <div style="position:absolute; left:0px; top:0px">
        <div id="sim" class="info" style="position:absolute; width: 0px;"></div>
        <div id="sms" class="info" style="position:absolute; width: 0px;"></div>
        <div id="drw" class="info" style="position:absolute; width: 0px;"></div>
        <div id="dms" class="info" style="position:absolute; width: 0px;"></div>

    </div> -->
    
    <div id='my-gui-container'></div>

    <!-- canvas must be square since simulator works in normalized device coordinates -->
    <canvas id="canvas2D" style="z-index: -1; position:absolute; left:300px; top:0px;"></canvas>
    <canvas id="canvas3D" style="z-index: -1; position:absolute; left:300px; top:0px;"></canvas>
    
    <div id='stats'>
        <h2>Default settings</h2>
        <p>OpenCL device: CPU</p>
    </div>

    <div id="output"></div>
    <form>
                 
        <!-- <input type="text" id="message" /> text form to send data to the server -->
        <!-- <input id="submit" type="button" value="Send data to Server"> -->
        <div id="content"></div> <!--This is where the data from the server is added-->
     
    </form>

    <script type="text/javascript">
                var socket = io.connect("/"); 
                
                $(function(){
                    $('#submit').click(function(){ /*listening to the button click using Jquery listener*/
                        
                        var data = document.getElementById("output").innerHTML;
                        socket.send(data);
     
                    });
                });
     
    </script>
    
</body>
</html>